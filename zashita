ITERATORS
Итератор - это объект, который содержит счетное(countable) число значений. Это объект, по которому можно выполнять итерации, что означает,
что вы можете просматривать все значения. Реализует протокол iterator, который состоит из методов __iter__ и __next__

List, tuple, set, dict - это все iterable(итерируемые) объекты. Из них мы можем получить iterator. iter(), next()

Создать Итератор
iter() - инициализирует. должен возвращать себя!
next() - производит операции, но должен возвращать себя всегда!

Мы можем остановить итерацию, используя raise StopIteration

modules - dir() - список(list) функций и переменых в модуле

DATETIME
import datetime
datetime.datetime.now() - время сейчас
формат времени: 2023-03-09 00:08:46.899667

Создать date объект - datetime.datetime(year, month, day) - обязательные.
Все остальное(hour, minute, second, microsecond, tzone) не обязательно(равно 0, tzone - none)

strftime() - метод для работы с датой, обработки в читаемый текст. Имеет один параметр: format

%a - день недели, короткая версия(Wed)
%A - день недели, длинная версия(Wednesday)
%w - день недели по счету(0-6б 0 - sunday)
%d - число месяца(01 - 31)
%b - месяц, короткий (Dec)
%B - месяц, длинный (December)
%m - месяц по счету(01-12)
%y - год, без века (23)
%Y - год, с веком (2023)
%H - часы, 24формат (0-23)
%I - часы, 12формат (0-12)
%p - AM/PM
%M - минуты (0-59)
%S - секунды (0-59)
%f - microsecond (000000 - 999999)
%z - UTC offset (+0100)
%Z - timezone (CST)
%U - число недели в году, sunday - первые день недели (0 - 53)
%W - число недели в году, monday - первый день недели (0 - 53)
%c - короткая время даты и время (Mon Dec 31 17:41:00 2018)
%C - век (20)
%x - локал версия даты (12/31/18)
%X - короткая версия времени (17:41:00)
%% - % знак


JSON
json - синтаксис для хранения и обмена данными. Это текст, написанный с помощью объектной нотации JavaScript
import json

parse json - convert json to python
json.loads() - результатом будет dict(python)

parse json - convert python to json
json.dumps() - dict, list, tuple, string, int, float, true, false, none
параметры: indept = 4 - кол-во отступов
separators = (", ", ": ") - по умолчанию. Первое для объектов, второе ключ-значение
json.dumps(x, indent=4, separators=(". ", " = "))
sort_keys = True - для сортировки ключей

GENERATORS
Генераторы - используются для создания итераторов. Он просматривает все элементы сразу.
Вместо return - yield - может использоватся много раз, и не прерывает функцию, а лишь приостанавливает, сохраняя все состояния
# Generator expression  
a = (x**3 for x in list)  

REGEX
Regular expression - последовательность символов, которая формирует шаблон поиска
используется для проверки того, содержит ли строка указанный шаблон поиска
import re

Regex func: 
re.findall() - возращает list со всеми найденными значениям, либо пустой список
re.search() - возращает match объект с первым найденным значением, либо None
re.split() - возращает список, разделяя строку по указанному шаблону
Параметр: maxsplit - макс. колво разделов. re.split("\s", txt, 1) (1 - maxsplit)
re.sub() - заменяет найденные по шаблону значения на другие
Параметр: count - макс число замен. re.sub("\s", "9", txt, 2)

Metacharacters
[] - набор символов
\ - сигнал о special sequence
. - любой символ
^ - начинается с ("^hello")
$ - заканчивается чем-то ("planet$")
* - ноль или больше вхождений
+ - одно или больше вхождений
? - ноль или одно вхождение
{} - точное количество вхождений
| - либо или
() - захват и группировка

Special sequence
\A - строка начинается с "\AThe"
\b - в начале или в конце слова (r"\bain", r"ain\b"), r - raw string(необработанная строка)
\B - не в начале или не в конце слова (обратное тому, что выше)
\d - digits(0-9)
\D - все кроме digits
\s - white space (пробел)
\S - все кроме white space (не пробел)
\w - возвращает word символ(a-Z, 0-9, _)
\W - все кроме word символов
\Z - строка заканчивается на "Spain\Z"

Sets
[arn] - возвращает либо a либо r либо n
[a-n] - возвращает совпадения от a до n
[^arn] - возвращает все, кроме a, r, n
[0123] - возвращает совпадение, в котором есть 0 или 1 или 2 или 3
[0-9] - возвращает все цифры между 0 и 9
[0-5][0-9] - возвращает все числа от 00 до 59
[a-zA-Z] - возвращает от a до Z (большой, маленький регистр)
[+] - ищет плюс(не имеет спец значения, как и другие символы внутри)

MATCH object
содержит информацию о поиске и результате.
Методы:
span() - (2,7) - начало и конец найденного вхождения
string - изначальный текст
group() - группа, часть текста, в котором было найдено вхождение

re.compile() - для компиляции шаблона, представленного в виде строки в объект шаблона regex(re.pattern).
Чтобы использован шаблон поиска для разных строк, без его перезаписи.
; pattern = re.compile(r'\d{3})
; res = pattern.findall(target_string)


FILE HANDLING
open() - для работы с файлами. Имеет 2 параметра: filename, mode:
"r" - read - значение по умолчанию. Открывает файл для чтения, ошибка - если файл не существует
"a" - append - открывает файл для добавления. Создает файл, если не существует
"w" - write - открывает файл для записи. Создает файл, если не существует
"x" - create - создает указанный файл, ошибка - если файл существует
f = open("demofile.txt")
"t" - text - значение по умолчанию. Тектовый режим
"b" - binary - двоичный режим(изображения и т.д)

при открытии для чтения f = open("demofile.txt", "r")
read() - прочитать файл полностью
read(5) - выведет только первые 5 символов
readline() - прочитать строку файла. если два раза, то первая, потом вторая строка и т.д
либо через for x in file (пройдется построчно)

close() - закрыть файл. Из-за буферизации, для того, чтобы изменения сохранились

Write to file
"a" - append - добавляет в конец файла
"w" - write - перезапишет файл(удалит все и вставить новое содержимое)
write(text) - записать текст в файл

Create to file
"x" - create - создаст файл, ошибка - если файл существует
"a" - append - создаст файл, если файл не существует
"w" - write - создаст файл, если файл не существует

Delete file
import os
os.remove(filename) - удалит файл
os.path.exists(path) - проверит, существует ли файл
os.rmdir(dirname) - удалит папку (только пустую)

OS - для работы с операционной системой
import os
os.name() - название модуля операционной системы ('posix', 'nt', 'os2', 'ce', 'java' and 'riscos'.)
os.mkdir(name) - создать папку
os.getcwd() - current working directory(CWD) - получить текущий рабочий каталог
os.chdir() - сменить рабочий каталог
os.rmdir() - удалить папку
os.error() - IOerror - появляется
os.rename(file, newname) - переименовать

os.access - проверить доступ
os.path.exists(path) - проверить существование пути/файла
os.access(path, R_OK) - read - читается
os.access(path, W_OK) - write - можно записывать
os.access(path, X_OK) - executed - возможность выполнения файла или открытия директории
os.access(path, F_OK) - проверка существования файла или каталога


datetime.timedelta(days = 5) - разница во времени(содержит разницу 5 дней)

(x-y).seconds - разница во времени в секундах

f"{x[0] : <43}", " " * 26, f"{x[1] : ^11}{x[2] : <0}" - форматирование, выравнивание текста.
< налево, ^ - по середине, > - справа, f - float, d - int

re.findall("ab{2,3}", txt) - b встречается от 2 до 3 раз. От и до {x, y}

re.sub(r"([a-z])([A-Z])", r"\1 \2", txt) - групировка в скобках ()() и обращаться можно по номеру скобок \1 \2 \3 ..

math.prod - переумножает все значение в list, tuple, set и т.д

ord(x) - представляет в unicode. Тот же ASCII

reversed(x) - reversed iterator object. Возвращает перевернутую строку, последовательность

time.sleep() - сколько ждать в секундах(пауза)

all() - если все элементы имеют значение True, то тогда true, если хоть 1 нет, то false

os.listdir(path) - список с названиями папок и файлов.
os.path.isdir() - проверяет, это папка или нет
os.path.join(path, x) - объединяет путь и имя файла и получается новый путь
os.path.splitext(path) - возвращает список, где название и расширение файла отдельно
os.path.basename() - получает имя конечной папки или файла в пути, без пути
os.path.dirname() - получает имя конечной папки в пути, с путем!

r - сырая строка. raw string. необработанные строки.
нужны чтобы слеш \ не вызывал экранизирование символов.